package amitkma.stitch.compiler;

import static com.google.auto.common.MoreElements.getPackage;

import com.google.common.collect.ImmutableList;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;

import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;

import amitkma.stitch.compiler.utils.Constants;

/**
 * Create by Amit Kumar on 16/5/17
 * Email : mr.doc10jl96@gmail.com
 * Company : Dot Wave Ltd.
 */

/**
 * Class for code generation after processing annotations
 * ({@link amitkma.stitch.annotations.CallOnAnyThread},
 * {@link amitkma.stitch.annotations.CallOnNewThread},
 * {@link amitkma.stitch.annotations.CallOnUiThread})
 */
final class StitchGenerator {

    // Prefix to append in the generated class name.
    private static final String PREFIX = "Stitch";

    private final TypeName mTargetTypeName;
    private final ClassName mGeneratingClassName;
    private final ImmutableList<MethodThreadStitching> mMethodThreadStitchings;
    private final ClassName mBackgroundExecutor;
    private final ClassName mUiExecutor;
    private final ClassName mNewThreadExecutor;

    private StitchGenerator(TypeName targetTypeName, ClassName generatingClassName,
            ImmutableList<MethodThreadStitching> methodThreadStitchings) {

        this.mTargetTypeName = targetTypeName;
        this.mGeneratingClassName = generatingClassName;
        this.mMethodThreadStitchings = methodThreadStitchings;
        mNewThreadExecutor = ClassName.get("amitkma.stitchlib.executors", "NewThreadExecutor");
        mUiExecutor = ClassName.get("amitkma.stitchlib.executors", "UiExecutor");
        mBackgroundExecutor = ClassName.get("amitkma.stitchlib.executors", "BackgroundExecutor");
    }

    JavaFile makeFile() {
        return JavaFile.builder(mGeneratingClassName.packageName(), createType())
                .addFileComment("This file is generated by STITCH. Do not modify it!!!")
                .build();
    }

    private TypeSpec createType() {
        FieldSpec fieldSpec = FieldSpec.builder(mTargetTypeName, "target")
                .addModifiers(Modifier.PRIVATE)
                .addJavadoc("Private field of targeted class.").build();
        TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(mGeneratingClassName)
                .addModifiers(Modifier.PUBLIC)
                .addField(fieldSpec)
                .addMethod(constructor())
                .addMethod(stitchMethod());
        for (MethodThreadStitching binding : mMethodThreadStitchings) {

            MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(binding.getName())
                    .addModifiers(Modifier.PUBLIC);

            StringBuilder returnStatementBuilder = new StringBuilder("target.");
            returnStatementBuilder.append(binding.getName())
                    .append('(');
            List<MethodParameter> methodParameterList = binding.getMethodParameterList();
            if (methodParameterList != null && methodParameterList.size() > 0) {
                for (int i = 0; i < methodParameterList.size(); i++) {
                    methodSpecBuilder
                            .addParameter(methodParameterList.get(i).getTypeName(),
                                    methodParameterList.get(i).getName(), Modifier.FINAL);
                    if (i != methodParameterList.size() - 1) {
                        returnStatementBuilder.append(methodParameterList.get(i).getName());
                        returnStatementBuilder.append(", ");
                    } else {
                        returnStatementBuilder.append(methodParameterList.get(i).getName());
                    }
                }
            }

            returnStatementBuilder.append(')');

            if (binding.getThreadType() == Constants.TYPE_ANY_THREAD) {
                prepareAnyThreadMethod(binding, methodSpecBuilder,
                        returnStatementBuilder.toString());
            } else if (binding.getThreadType() == Constants.TYPE_UI_THREAD) {
                prepareUiThreadMethod(binding, methodSpecBuilder,
                        returnStatementBuilder.toString());
            } else if (binding.getThreadType() == Constants.TYPE_NEW_THREAD) {
                prepareNewThreadMethod(binding, methodSpecBuilder,
                        returnStatementBuilder.toString());
            }
            methodSpecBuilder.addJavadoc("Generated method.");
            typeSpecBuilder.addMethod(methodSpecBuilder.build());
        }
        return typeSpecBuilder.build();
    }

    private void prepareNewThreadMethod(MethodThreadStitching binding,
            MethodSpec.Builder methodSpecBuilder, String returnStatement) {
        if (binding.getReturnType() == TypeName.VOID) {
            methodSpecBuilder
                    .returns(TypeName.VOID);
            methodSpecBuilder
                    .addStatement("$T.getInstance().submitVoidTask($L)",
                            mNewThreadExecutor,
                            TypeSpec.anonymousClassBuilder("")
                                    .addSuperinterface(ClassName.get(Runnable.class))
                                    .addMethod(MethodSpec.methodBuilder("run")
                                            .addAnnotation(Override.class)
                                            .addModifiers(Modifier.PUBLIC)
                                            .returns(binding.getReturnType())
                                            .addStatement("$L", returnStatement)
                                            .build())
                                    .build());
        } else {
            methodSpecBuilder
                    .returns(binding.getReturnType().box());
            methodSpecBuilder
                    .beginControlFlow("try")
                    .addStatement("return $T.getInstance().submitCallableTask($L)",
                            mNewThreadExecutor,
                            TypeSpec.anonymousClassBuilder("")
                                    .addSuperinterface(ParameterizedTypeName
                                            .get(ClassName.get(Callable.class),
                                                    binding.getReturnType().box()))
                                    .addMethod(MethodSpec.methodBuilder("call")
                                            .addAnnotation(Override.class)
                                            .addModifiers(Modifier.PUBLIC)
                                            .addException(Exception.class)
                                            .returns(binding.getReturnType().box())
                                            .addStatement("return $L", returnStatement)
                                            .build())
                                    .build())
                    .nextControlFlow(Constants.CATCH_BLOCK, InterruptedException.class)
                    .addStatement(Constants.PRINT_STACKTRACE)
                    .addStatement(Constants.RETURN_NULL)
                    .nextControlFlow(Constants.CATCH_BLOCK, ExecutionException.class)
                    .addStatement(Constants.PRINT_STACKTRACE)
                    .addStatement(Constants.RETURN_NULL)
                    .endControlFlow();
        }

    }

    private void prepareUiThreadMethod(MethodThreadStitching binding,
            MethodSpec.Builder methodSpecBuilder, String returnStatement) {
        methodSpecBuilder
                .returns(TypeName.VOID);
        methodSpecBuilder
                .addStatement("$T.getInstance().execute($L)",
                        mUiExecutor,
                        TypeSpec.anonymousClassBuilder("")
                                .addSuperinterface(ClassName.get(Runnable.class))
                                .addMethod(MethodSpec.methodBuilder("run")
                                        .addAnnotation(Override.class)
                                        .addModifiers(Modifier.PUBLIC)
                                        .returns(binding.getReturnType())
                                        .addStatement("$L", returnStatement)
                                        .build())
                                .build());
    }

    private void prepareAnyThreadMethod(MethodThreadStitching binding,
            MethodSpec.Builder methodSpecBuilder, String returnStatement) {
        if (binding.getReturnType() == TypeName.VOID) {
            methodSpecBuilder
                    .returns(TypeName.VOID);
            methodSpecBuilder
                    .addStatement("$T.getInstance().submitVoidTask($L)",
                            mBackgroundExecutor,
                            TypeSpec.anonymousClassBuilder("")
                                    .addSuperinterface(ClassName.get(Runnable.class))
                                    .addMethod(MethodSpec.methodBuilder("run")
                                            .addAnnotation(Override.class)
                                            .addModifiers(Modifier.PUBLIC)
                                            .returns(binding.getReturnType())
                                            .addStatement("$L", returnStatement)
                                            .build())
                                    .build());
        } else {
            methodSpecBuilder
                    .returns(binding.getReturnType().box());
            methodSpecBuilder
                    .beginControlFlow("try")
                    .addStatement("return $T.getInstance().submitCallableTask($L)",
                            mBackgroundExecutor,
                            TypeSpec.anonymousClassBuilder("")
                                    .addSuperinterface(ParameterizedTypeName
                                            .get(ClassName.get(Callable.class),
                                                    binding.getReturnType().box()))
                                    .addMethod(MethodSpec.methodBuilder("call")
                                            .addAnnotation(Override.class)
                                            .addModifiers(Modifier.PUBLIC)
                                            .addException(Exception.class)
                                            .returns(binding.getReturnType().box())
                                            .addStatement("return $L", returnStatement)
                                            .build())
                                    .build())
                    .nextControlFlow(Constants.CATCH_BLOCK, InterruptedException.class)
                    .addStatement(Constants.PRINT_STACKTRACE)
                    .addStatement(Constants.RETURN_NULL)
                    .nextControlFlow(Constants.CATCH_BLOCK, ExecutionException.class)
                    .addStatement(Constants.PRINT_STACKTRACE)
                    .addStatement(Constants.RETURN_NULL)
                    .endControlFlow();
        }
    }

    private MethodSpec stitchMethod() {
        return MethodSpec.methodBuilder("stitch")
                .addJavadoc(
                        "Method for injection of target class into this generated class "
                                + "{@link $T}\n",

                        mGeneratingClassName)
                .addJavadoc("@param target Instance of the target class which is injected here.")
                .addParameter(mTargetTypeName, "target")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .addStatement("$L $L = new $T()",
                        mGeneratingClassName.simpleName(), mGeneratingClassName.simpleName()
                                .toLowerCase(),
                        mGeneratingClassName)
                .addStatement("$L.target = target", mGeneratingClassName.simpleName().toLowerCase())
                .addStatement("return $L", mGeneratingClassName.simpleName().toLowerCase())
                .returns(mGeneratingClassName)
                .build();
    }

    private MethodSpec constructor() {
        return MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PRIVATE)
                .addComment("No instances")
                .build();
    }

    static Builder newBuilder(TypeElement typeElement) {
        ClassName annotatedClassName = ClassName.get(typeElement);
        String packageName = getPackage(typeElement).getQualifiedName().toString();
        String annotatedClassNameString = typeElement.getQualifiedName().toString().substring(
                packageName.length() + 1).replace('.', '$');
        ClassName generatedClassName = ClassName.get(packageName,
                annotatedClassNameString + PREFIX);
        return new Builder(annotatedClassName, generatedClassName);
    }

    static final class Builder {

        private final ClassName mAnnotatedClassName;
        private final ClassName mGeneratedClassName;

        private final ImmutableList.Builder<MethodThreadStitching> mMethodStitchingList =
                ImmutableList
                        .builder();

        Builder(ClassName annotatedClassName, ClassName generatedClassName) {
            this.mAnnotatedClassName = annotatedClassName;
            this.mGeneratedClassName = generatedClassName;
        }

        void addMethod(MethodThreadStitching method) {
            mMethodStitchingList.add(method);
        }

        StitchGenerator build() {
            return new StitchGenerator(mAnnotatedClassName, mGeneratedClassName,
                    mMethodStitchingList.build());
        }
    }

}
